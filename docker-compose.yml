version: "3.9"

name: luka-ops
services:
  redis:
    image: redis:7-alpine
    container_name: redis
    command: ["redis-server", "--appendonly", "yes"]
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 5s
      timeout: 2s
      retries: 20
    volumes:
      - redis_data:/data
    networks: [luka]
    restart: unless-stopped

  # HTTP→Redis bridge; also serves /state and /metrics to the Worker (via cloudflared)
  bridge:
    image: node:20-alpine
    container_name: http_redis_bridge
    working_dir: /app
    environment:
      REDIS_URL: ${REDIS_URL}
      BRIDGE_TOKEN: ${BRIDGE_TOKEN}
      REPO_PATH: /app
      TZ: ${TZ}
      # NEW — feature flags
      LAB_UI: ${LAB_UI}
      OPS_AUDIT_VIEW: ${OPS_AUDIT_VIEW}
      CFG_EDIT: ${CFG_EDIT}
      CFG_REQUIRE_CONFIRM: ${CFG_REQUIRE_CONFIRM}
      OPS_DIGEST: ${OPS_DIGEST}
      OPS_CORRELATE_MODE: ${OPS_CORRELATE_MODE}
      OPS_CORRELATE_REPORTS: ${OPS_CORRELATE_REPORTS}
      PREDICTIVE_MODE: ${PREDICTIVE_MODE}
      PREDICTIVE_REPORTS: ${PREDICTIVE_REPORTS}
      FEDERATION_MODE: ${FEDERATION_MODE}
      AUTO_MODE: ${AUTO_MODE}
      # Secret guard flags (Phase 8.4 Enhanced)
      ALLOW_SECRET_EDITS: ${ALLOW_SECRET_EDITS}
      SAFE_EDIT_KEYS: ${SAFE_EDIT_KEYS}
      DENY_EDIT_KEYS: ${DENY_EDIT_KEYS}
      SECRET_PATTERNS: ${SECRET_PATTERNS}
      # Federation flags (Phase 8.8)
      FEDERATION_PEERS: ${FEDERATION_PEERS}
      FEDERATION_PEER_TOKENS: ${FEDERATION_PEER_TOKENS}
      FEDERATION_TIMEOUT_MS: ${FEDERATION_TIMEOUT_MS}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    depends_on:
      redis:
        condition: service_healthy
    command: ["node", "g/tools/services/http_redis_bridge.cjs"]
    networks: [luka]
    ports:
      - "127.0.0.1:8788:8788"  # optional: host-only for debugging
    restart: unless-stopped

  # CLC listener (flip modes via Redis; writes g/state/*.env in the bind-mounted repo)
  clc_listener:
    image: node:20-alpine
    container_name: clc_listener
    working_dir: /app
    environment:
      REDIS_URL: ${REDIS_URL}
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    depends_on:
      redis:
        condition: service_healthy
    command: ["node", "g/tools/services/redis_export_mode_listener.cjs"]
    networks: [luka]
    restart: unless-stopped

  # Nightly verify (cron-in-a-container @ 02:15)
  nightly:
    build:
      context: ./nightly
      dockerfile: Dockerfile
    container_name: nightly_verify
    environment:
      REDIS_URL: ${REDIS_URL}
      TZ: ${TZ}
      # KIM_CHAT_ID no longer needed since we notify via Redis/UI; keep if you still publish somewhere.
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
      - nightly_logs:/var/log
    depends_on:
      redis:
        condition: service_healthy
    networks: [luka]
    restart: unless-stopped

  # Ops health watcher (monitors UI endpoints every 5 minutes)
  ops_health:
    image: node:20-alpine
    container_name: ops_health_watcher
    working_dir: /app
    environment:
      OPS_DOMAIN: ${OPS_DOMAIN}
      METRICS_FILE: /app/g/metrics/ops_health.json
      HEALTH_INTERVAL: 300000  # 5 minutes
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: ["node", "g/tools/services/ops_health_watcher.cjs"]
    networks: [luka]
    restart: unless-stopped

  # Alerts every 5 minutes (cron-in-a-container)
  ops_alerts:
    image: node:20-alpine
    container_name: ops_alerts
    working_dir: /app
    environment:
      REPO_PATH: /app
      ALERT_WEBHOOK_URL: ${ALERT_WEBHOOK_URL}
      ALERT_MIN_SUCCESS: ${ALERT_MIN_SUCCESS}
      ALERT_MAX_AVG_LAT_MS: ${ALERT_MAX_AVG_LAT_MS}
      ALERT_COOLDOWN_MIN: ${ALERT_COOLDOWN_MIN}
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: sh -lc 'echo "*/5 * * * * node /app/g/tools/services/ops_alerts.cjs >> /var/log/ops_alerts.log 2>&1" > /etc/crontabs/root && crond -f -l 8'
    depends_on:
      ops_health:
        condition: service_started
    networks: [luka]
    restart: unless-stopped

  # Daily report at 02:30 (cron-in-a-container)
  ops_daily:
    image: node:20-alpine
    container_name: ops_daily_report
    working_dir: /app
    environment:
      REPO_PATH: /app
      ALERT_WEBHOOK_URL: ${ALERT_WEBHOOK_URL}
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: sh -lc 'echo "30 2 * * * node /app/g/tools/services/ops_health_daily_report.cjs >> /var/log/ops_daily.log 2>&1" > /etc/crontabs/root && crond -f -l 8'
    depends_on:
      ops_health:
        condition: service_started
    networks: [luka]
    restart: unless-stopped

  # Phase 8.0 — Self-healing controller (uses Docker socket to restart services)
  ops_autoheal:
    image: node:20-alpine
    container_name: ops_autoheal
    working_dir: /app
    environment:
      REPO_PATH: /app
      ALERT_WEBHOOK_URL: ${ALERT_WEBHOOK_URL}
      AUTOHEAL_TARGETS: ${AUTOHEAL_TARGETS}
      AUTOHEAL_FAIL_CONSEC: ${AUTOHEAL_FAIL_CONSEC}
      AUTOHEAL_COOLDOWN_SEC: ${AUTOHEAL_COOLDOWN_SEC}
      AUTOHEAL_MAX_ATTEMPTS_30M: ${AUTOHEAL_MAX_ATTEMPTS_30M}
      TZ: ${TZ}
      DOCKER_BIN: docker
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
      - /var/run/docker.sock:/var/run/docker.sock   # required to restart containers
    command: sh -lc 'apk add --no-cache docker-cli >/dev/null 2>&1 || true; echo "* * * * * node /app/g/tools/services/ops_autoheal.cjs >> /var/log/ops_autoheal.log 2>&1" > /etc/crontabs/root && crond -f -l 8'
    depends_on:
      ops_health:
        condition: service_started
    networks: [luka]
    restart: unless-stopped

  # Phase 8.5 — AI Ops Digest (daily at 03:00)
  ops_digest:
    image: node:20-alpine
    container_name: ops_digest
    working_dir: /app
    environment:
      REPO_PATH: /app
      TZ: ${TZ}
      OPS_DIGEST: ${OPS_DIGEST}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: sh -lc 'echo "0 3 * * * node /app/g/tools/services/ops_digest.cjs >> /var/log/ops_digest.log 2>&1" > /etc/crontabs/root && crond -f -l 8'
    depends_on:
      - redis
    networks: [luka]
    restart: unless-stopped

  # Phase 8.6 — Incident Correlation (every 10 minutes)
  ops_correlation:
    image: node:20-alpine
    container_name: ops_correlation
    working_dir: /app
    environment:
      REPO_PATH: /app
      OPS_CORRELATE_MODE: ${OPS_CORRELATE_MODE}
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: sh -lc 'echo "*/10 * * * * node /app/g/tools/services/ops_correlation.cjs >> /var/log/ops_correlation.log 2>&1" > /etc/crontabs/root && crond -f -l 8'
    depends_on:
      - redis
    networks: [luka]
    restart: unless-stopped

  # Phase 8.7 — Predictive Maintenance (optional cron)
  ops_predict:
    image: node:20-alpine
    container_name: ops_predict
    working_dir: /app
    environment:
      REPO_PATH: /app
      PREDICTIVE_MODE: ${PREDICTIVE_MODE}
      PREDICTIVE_REPORTS: ${PREDICTIVE_REPORTS}
      TZ: ${TZ}
    volumes:
      - ${REPO_HOST_PATH}:/app:rw
    command: sh -lc 'node /app/g/tools/services/ops_predict.cjs > /dev/null 2>&1 || true'
    depends_on:
      - redis
    networks: [luka]
    restart: unless-stopped
    profiles: ["predict-cron"]  # start only with --profile predict-cron

  # OPTIONAL: Cloudflared Named Tunnel (routes /bridge* on ops.theedges.work → http://bridge:8788)
  cloudflared:
    image: cloudflare/cloudflared:2025.6.1
    container_name: cloudflared
    environment:
      TUNNEL_TOKEN: ${CLOUDFLARE_TUNNEL_TOKEN}
    command: ["tunnel", "--no-autoupdate", "run", "--token", "${CLOUDFLARE_TUNNEL_TOKEN}"]
    depends_on:
      bridge:
        condition: service_started
    networks: [luka]
    restart: unless-stopped
    # Only start if you actually set a token
    deploy:
      replicas: 1

networks:
  luka: {}

volumes:
  redis_data: {}
  nightly_logs: {}