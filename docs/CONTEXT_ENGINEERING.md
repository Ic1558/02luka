# ğŸ§  Context Engineering Guide
> **Scope:** 02luka-repo local workspace
> **Updated:** 2025-10-22T03:20:00Z (Phase 7.6+ added)

## System Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          Context Layer         â”‚
â”‚  - prompts/                   â”‚
â”‚  - .claude/commands/ (legacy)  â”‚
â”‚  - f/ai_context/*.json         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Luka Frontend  â”‚
        â”‚ (luka.html UI) â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ boss-api       â”‚
        â”‚ /api/chat      â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Local Gateways & Integrationsâ”‚
â”‚ - MCP Docker (5012)          â”‚
â”‚ - MCP FS (8765)              â”‚
â”‚ - MCP Verification API       â”‚
â”‚ - Linear-lite Sync Service   â”‚
â”‚ - Ollama (11434)             â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## Codex Template Usage Pattern
- **Always start from** `prompts/master_prompt.md` when drafting a task for Codex.
- Populate the `GOAL:` line with the mission statement, then fill sections for context, constraints, resources, validation, and follow-up.
- Store any project-specific variations inside `prompts/` to keep them discoverable through the mapping namespace `codex:*`.

## Installation & Maintenance
- Use `g/tools/install_master_prompt.sh` to install or refresh the templates. The script validates content hashes, creates backups, and prints usage reminders.
- `f/ai_context/mapping.json` (v2.2) now exposes the `codex` namespace + Phase 4 status surfaces so tooling can resolve paths
  like `codex:templates` and `codex:status:mcp`.
- Update the mapping whenever new template families are added so downstream bots inherit the structure.

## Integration Checklist
- [x] Luka UI prompt library reads from `prompts/master_prompt.md`.
- [x] Backend orchestration forwards prompt metadata through `/api/chat`.
- [x] MCP verification receipts appended to `g/reports/mcp_verify/` (Phase 4).
- [x] Linear-lite cache refresh emits SSE events to Luka UI sidebar.
- [ ] Automate template freshness checks inside `verify_system.sh` (planned).

### Phase 4 Context Bridges
- **Verification Surface:** Context layer now publishes `context/mcp_status.json` (generated by `/api/mcp/verify/status`).
- **Linear-lite Surface:** `f/ai_context/linear-lite/cards_active.json` mirrors `/api/linear-lite/cards?state=active`.
- **Change Detection:** `scripts/context/refresh_phase4.sh` (cron) diff-checks MCP + Linear-lite payloads and stores deltas in
  `g/reports/context_delta/` for audit.
- **Consumption:** Cursor and CLC prompts can pull `codex:status:mcp` and `codex:status:linear-lite` namespaces via mapping
  updates in `f/ai_context/mapping.json` (v2.2).

## LaunchAgent Health
- **Health Ratio:** 100% (all LaunchAgents validated after cleanup).
- **Notes:** MCP stack reporting healthy, zero configuration errors remaining.

## Runtime Path Rules

### ğŸš« Avoid CloudStorage Paths at Runtime
- **Never rely on** `GoogleDrive-ittipong.c@gmail.com/My Drive/...` paths for runtime operations
- **CloudStorage paths** are placeholders and may not be accessible in devcontainer environments
- **Use symlinked paths** instead: `~/dev/02luka-repo` for consistent access

### âœ… Preferred Path Patterns
- **Development Root**: `/workspaces/02luka-repo` (canonical, devcontainer) or `~/dev/02luka-repo` (optional symlink, host)
- **Memory Files**: `.codex/hybrid_memory_system.md` (local to repo)
- **Reports**: `g/reports/` (versioned under git)
- **Logs**: `/tmp/` or `g/reports/` (avoid CloudStorage for runtime logs)

### ğŸ”§ Path Resolution Strategy
1. **Use canonical workspace**: `/workspaces/02luka-repo` (devcontainer) - primary
2. **Optional symlink**: `~/dev/02luka-repo` (host) - for legacy compatibility
3. **Dynamic resolution**: Use `scripts/repo_root_resolver.sh` in all scripts
4. **Never assume CloudStorage**: Always use resolved paths for runtime
5. **Memory Bridge**: Uses repo-relative paths for portability
6. **Phase 4 Assets**: Verification + Linear-lite context dumps stored under `f/ai_context/phase4/`

## Vector Memory System

### Overview
The vector memory system provides semantic storage and retrieval of past experiences using TF-IDF vectors and cosine similarity. This enables agents to learn from previous tasks and recall relevant solutions.

### Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      memory/index.cjs               â”‚
â”‚  - TF-IDF Vectorization             â”‚
â”‚  - Cosine Similarity Search         â”‚
â”‚  - remember({kind, text, meta})     â”‚
â”‚  - recall({query, kind, topK})      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
             â”‚
             â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   g/memory/vector_index.json        â”‚
â”‚  - File-backed storage               â”‚
â”‚  - JSON Lines format                 â”‚
â”‚  - IDF scores for corpus             â”‚
â”‚  - Memory vectors                    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Integration Points

#### 1. Planner Integration (agents/lukacode/plan.cjs)
- **Before Planning**: Recalls top 3 relevant memories based on prompt
- **Output**: Includes `relevantMemories` in plan metadata
- **Purpose**: Shows agent past experiences with similar tasks

#### 2. Task Completion Hooks
- **After Success**: `run/ops_atomic.sh` remembers successful runs
- **After Success**: `run/smoke_api_ui.sh` remembers clean test runs
- **Kind**: `plan` (ops_atomic) or `solution` (smoke tests)
- **Purpose**: Build knowledge base of successful patterns

### API Reference

#### remember({kind, text, meta})
Store a memory with semantic embedding.

**Parameters:**
- `kind` (string): Memory type - `plan`, `solution`, `error`, custom
- `text` (string): Memory content to store
- `meta` (object, optional): Additional metadata

**Returns:**
```json
{
  "id": "plan_1760905932038_rhwv717",
  "kind": "plan",
  "timestamp": "2025-10-19T20:32:12.038Z"
}
```

**CLI Usage:**
```bash
node memory/index.cjs --remember plan "Successfully deployed Discord integration"
node memory/index.cjs --remember solution "Fixed macOS date command with \$(($(date +%s) * 1000))"
```

#### recall({query, kind, topK})
Retrieve similar memories using cosine similarity.

**Parameters:**
- `query` (string): Search query
- `kind` (string, optional): Filter by memory type
- `topK` (number, default: 5): Number of results to return

**Returns:**
```json
[
  {
    "id": "solution_1760905940644_wk9zzyt",
    "kind": "solution",
    "text": "Fixed macOS date command...",
    "meta": {},
    "timestamp": "2025-10-19T20:32:20.644Z",
    "similarity": 0.6405
  }
]
```

**CLI Usage:**
```bash
node memory/index.cjs --recall "How to fix date command on macOS?"
node memory/index.cjs --recall-kind solution "date command issues"
node memory/index.cjs --stats
```

### Storage Format

**File:** `g/memory/vector_index.json`

**Structure:**
```json
{
  "memories": [
    {
      "id": "plan_1760905932038_rhwv717",
      "kind": "plan",
      "text": "Implemented Discord integration...",
      "meta": {},
      "tokens": ["implemented", "discord", "integration", ...],
      "vector": {"implemented": 0.0549, "discord": 0.1098, ...},
      "timestamp": "2025-10-19T20:32:12.038Z"
    }
  ],
  "idf": {
    "implemented": 1.0986,
    "discord": 1.0986,
    ...
  }
}
```

### Memory Kinds

**Recommended Types:**
- `plan` - Successful task plans and execution summaries
- `solution` - Solutions to specific problems
- `error` - Error patterns and resolutions
- `insight` - Learned patterns or optimization discoveries
- `config` - Configuration patterns that worked

### Best Practices

1. **Be Specific**: Store detailed, actionable memories
   - âœ… "Fixed macOS date command incompatibility by replacing date +%s%3N with \$(($(date +%s) * 1000))"
   - âŒ "Fixed date command"

2. **Use Appropriate Kinds**: Categorize memories for better filtering
   - Plans â†’ `plan`
   - Bug fixes â†’ `solution`
   - New learnings â†’ `insight`

3. **Include Context**: Add relevant metadata when available
   - Commit hashes, timestamps, file paths
   - Performance metrics, test results

4. **Automatic Recording**: Hooks already in place for:
   - OPS atomic runs (successful only)
   - Smoke tests (successful only)
   - Planner now recalls memories before execution

### Maintenance

**Check Memory Stats:**
```bash
node memory/index.cjs --stats
```

**Clear All Memories** (use with caution):
```bash
node memory/index.cjs --clear
```

**Backup Index:**
```bash
cp g/memory/vector_index.json g/memory/vector_index.backup.json
```

### Future Enhancements
- [ ] Automatic cleanup of old/irrelevant memories
- [ ] Importance scoring for memory prioritization
- [ ] Integration with CI/CD for failure pattern detection
- [ ] Cross-agent memory sharing
- [ ] Metadata-based filtering (commit hash, file paths)
- [ ] Memory clustering for pattern discovery

---

## Phase 7.6+: Hybrid Embeddings System â­

**Status:** âœ… PRODUCTION READY (2025-10-22)
**Location:** `knowledge/`
**Model:** all-MiniLM-L6-v2 (384 dimensions, 80MB, offline)
**Database:** `knowledge/02luka.db` (SQLite, 14 MB)

### Architecture: 3-Stage Hybrid Pipeline

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 1: FTS Pre-filter (Fast)                              â”‚
â”‚ SQLite FTS5 â†’ Top 50 candidates                             â”‚
â”‚ Performance: ~4ms                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 2: Embedding Rerank (Precise)                         â”‚
â”‚ all-MiniLM-L6-v2 â†’ Cosine similarity                        â”‚
â”‚ Performance: ~3ms                                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Stage 3: Hybrid Scoring                                     â”‚
â”‚ Final = (0.3 Ã— FTS) + (0.7 Ã— Semantic)                      â”‚
â”‚ Performance: ~0.1ms                                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Quick Commands

```bash
# Hybrid search (best for most queries)
node knowledge/index.cjs --hybrid "query"

# With timing breakdown
node knowledge/index.cjs --verify "query"

# Benchmark performance
node knowledge/index.cjs --bench --iters=30

# Reindex all documents
node knowledge/index.cjs --reindex
```

### Coverage Statistics

- **258 documents** indexed (100% of docs/, g/reports/, memory/)
- **4,002 semantic chunks** created
- **7-8ms** average query time (ğŸš€ 12x better than <100ms target)
- **Zero waste paper** âœ… (all documentation searchable)

### Key Features

1. **Semantic Understanding**: Finds "token savings" when searching "cost reduction"
2. **Special Character Support**: "phase 7.2", "v2.0", "boss-api" all work correctly
3. **Hybrid Scoring**: Balances keyword precision (FTS) with semantic recall (embeddings)
4. **Offline-First**: No external APIs, runs on CPU using ONNX runtime
5. **Backward Compatible**: Old commands (--search, --recall, --stats) still work

### Use Cases

**When to Use Hybrid Search:**
- Finding documentation on any topic
- Discovering related concepts across different docs
- Understanding system architecture and past decisions
- **Before asking CLC questions** (saves tokens, instant answers)

**Example Queries:**
```bash
# Semantic search
node knowledge/index.cjs --hybrid "token efficiency improvements"
node knowledge/index.cjs --hybrid "how to reduce costs"

# Version/phase searches
node knowledge/index.cjs --hybrid "phase 7.2 delegation"
node knowledge/index.cjs --hybrid "version 2.0 deployment"

# Concept discovery
node knowledge/index.cjs --hybrid "performance optimization strategies"
```

### Token Savings vs TF-IDF (Phase 6)

| Approach | Coverage | Query Time | Semantic | Token Cost |
|----------|----------|------------|----------|------------|
| **Phase 6: TF-IDF** | 27 memories | N/A | âŒ Keyword only | 0 tokens |
| **Phase 7.6: Hybrid** | 4,002 chunks (258 docs) | 7-8ms | âœ… Full semantic | 0 tokens |

**Improvement:**
- Coverage: +14,700% chunks
- Docs: 0% â†’ 100% indexed
- Reports: 68% â†’ 100% indexed
- Semantic understanding: None â†’ Full

### Documentation

- **Implementation Report**: `g/reports/251022_HYBRID_VECTOR_DB_IMPLEMENTATION.md`
- **Verification Report**: `g/reports/251022_HYBRID_VDB_VERIFICATION.md`
- **User Guide**: `knowledge/README.md`
- **Quick Reference**: `g/reports/RAG_QUICK_REFERENCE.md`
- **System Overview**: `02luka.md` (Phase 7.6+ section)

