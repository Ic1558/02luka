# 🧠 Context Engineering Guide
> **Scope:** 02luka-repo local workspace
> **Updated:** 2025-10-22T03:20:00Z (Phase 7.6+ added)

## System Architecture
```
┌───────────────────────────────┐
│          Context Layer         │
│  - prompts/                   │
│  - .claude/commands/ (legacy)  │
│  - f/ai_context/*.json         │
└───────────────┬───────────────┘
                │
        ┌───────▼────────┐
        │ Luka Frontend  │
        │ (luka.html UI) │
        └───────┬────────┘
                │
        ┌───────▼────────┐
        │ boss-api       │
        │ /api/chat      │
        └───────┬────────┘
                │
┌───────────────▼──────────────┐
│ Local Gateways & Integrations│
│ - MCP Docker (5012)          │
│ - MCP FS (8765)              │
│ - MCP Verification API       │
│ - Linear-lite Sync Service   │
│ - Ollama (11434)             │
└──────────────────────────────┘
```

## Codex Template Usage Pattern
- **Always start from** `prompts/master_prompt.md` when drafting a task for Codex.
- Populate the `GOAL:` line with the mission statement, then fill sections for context, constraints, resources, validation, and follow-up.
- Store any project-specific variations inside `prompts/` to keep them discoverable through the mapping namespace `codex:*`.

## Installation & Maintenance
- Use `g/tools/install_master_prompt.sh` to install or refresh the templates. The script validates content hashes, creates backups, and prints usage reminders.
- `f/ai_context/mapping.json` (v2.2) now exposes the `codex` namespace + Phase 4 status surfaces so tooling can resolve paths
  like `codex:templates` and `codex:status:mcp`.
- Update the mapping whenever new template families are added so downstream bots inherit the structure.

## Integration Checklist
- [x] Luka UI prompt library reads from `prompts/master_prompt.md`.
- [x] Backend orchestration forwards prompt metadata through `/api/chat`.
- [x] MCP verification receipts appended to `g/reports/mcp_verify/` (Phase 4).
- [x] Linear-lite cache refresh emits SSE events to Luka UI sidebar.
- [ ] Automate template freshness checks inside `verify_system.sh` (planned).

### Phase 4 Context Bridges
- **Verification Surface:** Context layer now publishes `context/mcp_status.json` (generated by `/api/mcp/verify/status`).
- **Linear-lite Surface:** `f/ai_context/linear-lite/cards_active.json` mirrors `/api/linear-lite/cards?state=active`.
- **Change Detection:** `scripts/context/refresh_phase4.sh` (cron) diff-checks MCP + Linear-lite payloads and stores deltas in
  `g/reports/context_delta/` for audit.
- **Consumption:** Cursor and CLC prompts can pull `codex:status:mcp` and `codex:status:linear-lite` namespaces via mapping
  updates in `f/ai_context/mapping.json` (v2.2).

## LaunchAgent Health
- **Health Ratio:** 100% (all LaunchAgents validated after cleanup).
- **Notes:** MCP stack reporting healthy, zero configuration errors remaining.

## Runtime Path Rules

### 🚫 Avoid CloudStorage Paths at Runtime
- **Never rely on** `GoogleDrive-ittipong.c@gmail.com/My Drive/...` paths for runtime operations
- **CloudStorage paths** are placeholders and may not be accessible in devcontainer environments
- **Use symlinked paths** instead: `~/dev/02luka-repo` for consistent access

### ✅ Preferred Path Patterns
- **Development Root**: `/workspaces/02luka-repo` (canonical, devcontainer) or `~/dev/02luka-repo` (optional symlink, host)
- **Memory Files**: `.codex/hybrid_memory_system.md` (local to repo)
- **Reports**: `g/reports/` (versioned under git)
- **Logs**: `/tmp/` or `g/reports/` (avoid CloudStorage for runtime logs)

### 🔧 Path Resolution Strategy
1. **Use canonical workspace**: `/workspaces/02luka-repo` (devcontainer) - primary
2. **Optional symlink**: `~/dev/02luka-repo` (host) - for legacy compatibility
3. **Dynamic resolution**: Use `scripts/repo_root_resolver.sh` in all scripts
4. **Never assume CloudStorage**: Always use resolved paths for runtime
5. **Memory Bridge**: Uses repo-relative paths for portability
6. **Phase 4 Assets**: Verification + Linear-lite context dumps stored under `f/ai_context/phase4/`

## Vector Memory System

### Overview
The vector memory system provides semantic storage and retrieval of past experiences using TF-IDF vectors and cosine similarity. This enables agents to learn from previous tasks and recall relevant solutions.

### Architecture
```
┌─────────────────────────────────────┐
│      memory/index.cjs               │
│  - TF-IDF Vectorization             │
│  - Cosine Similarity Search         │
│  - remember({kind, text, meta})     │
│  - recall({query, kind, topK})      │
└────────────┬────────────────────────┘
             │
             ▼
┌─────────────────────────────────────┐
│   g/memory/vector_index.json        │
│  - File-backed storage               │
│  - JSON Lines format                 │
│  - IDF scores for corpus             │
│  - Memory vectors                    │
└─────────────────────────────────────┘
```

### Integration Points

#### 1. Planner Integration (agents/lukacode/plan.cjs)
- **Before Planning**: Recalls top 3 relevant memories based on prompt
- **Output**: Includes `relevantMemories` in plan metadata
- **Purpose**: Shows agent past experiences with similar tasks

#### 2. Task Completion Hooks
- **After Success**: `run/ops_atomic.sh` remembers successful runs
- **After Success**: `run/smoke_api_ui.sh` remembers clean test runs
- **Kind**: `plan` (ops_atomic) or `solution` (smoke tests)
- **Purpose**: Build knowledge base of successful patterns

### API Reference

#### remember({kind, text, meta})
Store a memory with semantic embedding.

**Parameters:**
- `kind` (string): Memory type - `plan`, `solution`, `error`, custom
- `text` (string): Memory content to store
- `meta` (object, optional): Additional metadata

**Returns:**
```json
{
  "id": "plan_1760905932038_rhwv717",
  "kind": "plan",
  "timestamp": "2025-10-19T20:32:12.038Z"
}
```

**CLI Usage:**
```bash
node memory/index.cjs --remember plan "Successfully deployed Discord integration"
node memory/index.cjs --remember solution "Fixed macOS date command with \$(($(date +%s) * 1000))"
```

#### recall({query, kind, topK})
Retrieve similar memories using cosine similarity.

**Parameters:**
- `query` (string): Search query
- `kind` (string, optional): Filter by memory type
- `topK` (number, default: 5): Number of results to return

**Returns:**
```json
[
  {
    "id": "solution_1760905940644_wk9zzyt",
    "kind": "solution",
    "text": "Fixed macOS date command...",
    "meta": {},
    "timestamp": "2025-10-19T20:32:20.644Z",
    "similarity": 0.6405
  }
]
```

**CLI Usage:**
```bash
node memory/index.cjs --recall "How to fix date command on macOS?"
node memory/index.cjs --recall-kind solution "date command issues"
node memory/index.cjs --stats
```

### Storage Format

**File:** `g/memory/vector_index.json`

**Structure:**
```json
{
  "memories": [
    {
      "id": "plan_1760905932038_rhwv717",
      "kind": "plan",
      "text": "Implemented Discord integration...",
      "meta": {},
      "tokens": ["implemented", "discord", "integration", ...],
      "vector": {"implemented": 0.0549, "discord": 0.1098, ...},
      "timestamp": "2025-10-19T20:32:12.038Z"
    }
  ],
  "idf": {
    "implemented": 1.0986,
    "discord": 1.0986,
    ...
  }
}
```

### Memory Kinds

**Recommended Types:**
- `plan` - Successful task plans and execution summaries
- `solution` - Solutions to specific problems
- `error` - Error patterns and resolutions
- `insight` - Learned patterns or optimization discoveries
- `config` - Configuration patterns that worked

### Best Practices

1. **Be Specific**: Store detailed, actionable memories
   - ✅ "Fixed macOS date command incompatibility by replacing date +%s%3N with \$(($(date +%s) * 1000))"
   - ❌ "Fixed date command"

2. **Use Appropriate Kinds**: Categorize memories for better filtering
   - Plans → `plan`
   - Bug fixes → `solution`
   - New learnings → `insight`

3. **Include Context**: Add relevant metadata when available
   - Commit hashes, timestamps, file paths
   - Performance metrics, test results

4. **Automatic Recording**: Hooks already in place for:
   - OPS atomic runs (successful only)
   - Smoke tests (successful only)
   - Planner now recalls memories before execution

### Maintenance

**Check Memory Stats:**
```bash
node memory/index.cjs --stats
```

**Clear All Memories** (use with caution):
```bash
node memory/index.cjs --clear
```

**Backup Index:**
```bash
cp g/memory/vector_index.json g/memory/vector_index.backup.json
```

### Future Enhancements
- [ ] Automatic cleanup of old/irrelevant memories
- [ ] Importance scoring for memory prioritization
- [ ] Integration with CI/CD for failure pattern detection
- [ ] Cross-agent memory sharing
- [ ] Metadata-based filtering (commit hash, file paths)
- [ ] Memory clustering for pattern discovery

---

## Phase 7.6+: Hybrid Embeddings System ⭐

**Status:** ✅ PRODUCTION READY (2025-10-22)
**Location:** `knowledge/`
**Model:** all-MiniLM-L6-v2 (384 dimensions, 80MB, offline)
**Database:** `knowledge/02luka.db` (SQLite, 14 MB)

### Architecture: 3-Stage Hybrid Pipeline

```
┌─────────────────────────────────────────────────────────────┐
│ Stage 1: FTS Pre-filter (Fast)                              │
│ SQLite FTS5 → Top 50 candidates                             │
│ Performance: ~4ms                                            │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ Stage 2: Embedding Rerank (Precise)                         │
│ all-MiniLM-L6-v2 → Cosine similarity                        │
│ Performance: ~3ms                                            │
└─────────────────────────────────────────────────────────────┘
                           ↓
┌─────────────────────────────────────────────────────────────┐
│ Stage 3: Hybrid Scoring                                     │
│ Final = (0.3 × FTS) + (0.7 × Semantic)                      │
│ Performance: ~0.1ms                                          │
└─────────────────────────────────────────────────────────────┘
```

### Quick Commands

```bash
# Hybrid search (best for most queries)
node knowledge/index.cjs --hybrid "query"

# With timing breakdown
node knowledge/index.cjs --verify "query"

# Benchmark performance
node knowledge/index.cjs --bench --iters=30

# Reindex all documents
node knowledge/index.cjs --reindex
```

### Coverage Statistics

- **258 documents** indexed (100% of docs/, g/reports/, memory/)
- **4,002 semantic chunks** created
- **7-8ms** average query time (🚀 12x better than <100ms target)
- **Zero waste paper** ✅ (all documentation searchable)

### Key Features

1. **Semantic Understanding**: Finds "token savings" when searching "cost reduction"
2. **Special Character Support**: "phase 7.2", "v2.0", "boss-api" all work correctly
3. **Hybrid Scoring**: Balances keyword precision (FTS) with semantic recall (embeddings)
4. **Offline-First**: No external APIs, runs on CPU using ONNX runtime
5. **Backward Compatible**: Old commands (--search, --recall, --stats) still work

### Use Cases

**When to Use Hybrid Search:**
- Finding documentation on any topic
- Discovering related concepts across different docs
- Understanding system architecture and past decisions
- **Before asking CLC questions** (saves tokens, instant answers)

**Example Queries:**
```bash
# Semantic search
node knowledge/index.cjs --hybrid "token efficiency improvements"
node knowledge/index.cjs --hybrid "how to reduce costs"

# Version/phase searches
node knowledge/index.cjs --hybrid "phase 7.2 delegation"
node knowledge/index.cjs --hybrid "version 2.0 deployment"

# Concept discovery
node knowledge/index.cjs --hybrid "performance optimization strategies"
```

### Token Savings vs TF-IDF (Phase 6)

| Approach | Coverage | Query Time | Semantic | Token Cost |
|----------|----------|------------|----------|------------|
| **Phase 6: TF-IDF** | 27 memories | N/A | ❌ Keyword only | 0 tokens |
| **Phase 7.6: Hybrid** | 4,002 chunks (258 docs) | 7-8ms | ✅ Full semantic | 0 tokens |

**Improvement:**
- Coverage: +14,700% chunks
- Docs: 0% → 100% indexed
- Reports: 68% → 100% indexed
- Semantic understanding: None → Full

### Documentation

- **Implementation Report**: `g/reports/251022_HYBRID_VECTOR_DB_IMPLEMENTATION.md`
- **Verification Report**: `g/reports/251022_HYBRID_VDB_VERIFICATION.md`
- **User Guide**: `knowledge/README.md`
- **Quick Reference**: `g/reports/RAG_QUICK_REFERENCE.md`
- **System Overview**: `02luka.md` (Phase 7.6+ section)

