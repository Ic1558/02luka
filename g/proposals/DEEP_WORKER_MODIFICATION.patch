--- a/path/to/deep_engine_worker.py
+++ b/path/to/deep_engine_worker.py
@@ -25,18 +25,23 @@
 # 1. Load config for the 'deep' engine
 deep_config = load_engine_config("deep")
 
-# 2. Assemble the command string from the config
-cmd = deep_config["cli"]["codex_cmd"]
+# 2. Determine which command to run based on the mode
+mode = deep_config.get("mode", "codex") # Default to 'codex' if not specified
+
+if mode == "codex":
+    cmd = deep_config["cli"]["codex_cmd"]
+elif mode == "api":
+    cmd = deep_config["api"]["runner_cmd"]
+else:
+    raise RuntimeError(f"Unknown deep engine mode: {mode}")
 
 # 3. Send the payload/prompt to the selected engine command
-proc = subprocess.run(
-    cmd, 
-    input=prompt_text.encode("utf-8"),
+def run_deep_engine(cmd: str, payload: str, timeout: int) -> str:
+    proc = subprocess.run(
+        cmd,
+        input=payload.encode("utf-8"),
+        stdout=subprocess.PIPE,
+        stderr=subprocess.PIPE,
+        shell=True,
+        timeout=timeout,
+    )
+    if proc.returncode != 0:
+        # Proper error handling should be added here
+        raise RuntimeError(f"Deep engine command failed: {proc.stderr.decode('utf-8', 'ignore')}")
+    return proc.stdout.decode("utf-8", "ignore").strip()
+
+# Execute the engine
+deep_text_result = run_deep_engine(cmd, prompt_text, deep_config.get("timeout_seconds", 240))
 
-    stdout=subprocess.PIPE, 
-    stderr=subprocess.PIPE, 
-    shell=True, 
-    timeout=deep_config.get("timeout_sec", 240)
-)
-
-# 4. Get the output and process it
-result_text = proc.stdout.decode("utf-8", "ignore").strip()
-record["codex_returned"] = result_text
+# 4. Get the output and process it (assuming 'record' is a dict being prepared)
+record["api_returned"] = deep_text_result # Or use a more generic key like 'engine_output'
 # ... rest of the ledger and CLC inbox logic remains the same ...

