#!/usr/bin/env node
/* eslint-disable no-console */
const fs = require('fs');
const path = require('path');

const ROOT = process.cwd();
const TDIR = path.join(ROOT, 'g', 'telemetry');
const RDIR = path.join(ROOT, 'g', 'reports');
const TODAY = new Date();
const YYYYMMDD = TODAY.toISOString().slice(0,10).replace(/-/g,'');
const sinceMs = parseSinceArg(process.argv) ?? 24*60*60*1000;

ensureDir(RDIR);
ensureDir(TDIR);

const files = {
  search: pickExisting([
    path.join(TDIR, 'search.ndjson'),
    path.join(TDIR, 'sample', 'search.ndjson')
  ]),
  alerts: pickExisting([
    path.join(TDIR, 'alerts.ndjson'),
    path.join(TDIR, 'sample', 'alerts.ndjson')
  ]),
  autoheal: pickExisting([
    path.join(TDIR, 'autoheal.log'),
    path.join(TDIR, 'sample', 'autoheal.log')
  ])
};

const windowStart = Date.now() - sinceMs;

const search = readJSONL(files.search).filter(r => tsMs(r.ts) >= windowStart);
const alerts = readJSONL(files.alerts).filter(r => tsMs(r.ts) >= windowStart);
const autoheal = readJSONL(files.autoheal).filter(r => tsMs(r.ts) >= windowStart);

// Metrics
const count = search.length || 1;
const took = search.map(r => Number(r.took_ms)||0).sort((a,b)=>a-b);
const avg = Math.round(took.reduce((a,b)=>a+b,0) / count);
const p95 = took[Math.min(took.length-1, Math.floor(took.length*0.95))] || 0;
const hits = search.filter(r => r.cache === 'hit').length;
const miss = search.filter(r => r.cache === 'miss').length;
const hitRate = hits + miss ? hits/(hits+miss) : 0;

const sevCounts = ['info','warn','error'].reduce((m,s)=> (m[s]=0,m),{});
alerts.forEach(a => { if (sevCounts[a.severity]!=null) sevCounts[a.severity]++; });

const healCount = autoheal.length;

// Write NDJSON rollup
const rollPath = path.join(TDIR, 'rollup_daily.ndjson');
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'cache_hit_rate', value: round(hitRate,4) });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'query_avg_ms',  value: avg });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'query_p95_ms',  value: p95 });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'autoheal_events',value: healCount });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'alerts_total',  value: alerts.length });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'alerts_warn',   value: sevCounts.warn });
appendJSONL(rollPath, { ts: isoAt(9,0), metric: 'alerts_error',  value: sevCounts.error });

// Write Markdown report
const md = `# ðŸ§¾ Daily Digest â€“ ${TODAY.toISOString().slice(0,10)}
Window: last ${Math.round(sinceMs/3600000)}h

## Summary
| Metric | Value |
|:--|--:|
| Cache Hit Rate | ${(hitRate*100).toFixed(1)} % |
| Avg Query Latency | ${avg} ms |
| p95 Query Latency | ${p95} ms |
| Autoheal Events | ${healCount} |
| Alerts (info/warn/error) | ${sevCounts.info} / ${sevCounts.warn} / ${sevCounts.error} |

Notes:
- Generated by daily_digest.cjs
`;
const mdPath = path.join(RDIR, `daily_digest_${YYYYMMDD}.md`);
fs.writeFileSync(mdPath, md);

// Optional Discord ping
if (process.env.DISCORD_WEBHOOK_DEFAULT) {
  try {
    require('child_process').execSync(
      `curl -sS -H "Content-Type: application/json" -d ${shq(JSON.stringify({
        content: `**Daily Digest** ${TODAY.toISOString().slice(0,10)} â€¢ hit ${(hitRate*100).toFixed(1)}% â€¢ p95 ${p95}ms â€¢ alerts ${alerts.length} â€¢ autoheal ${healCount}`
      }))} ${shq(process.env.DISCORD_WEBHOOK_DEFAULT)}`
    );
  } catch (_) {}
}

console.log(`Digest OK â†’ ${mdPath}`);
process.exit(0);

// helpers
function parseSinceArg(argv){
  const i=argv.indexOf('--since'); if(i> -1 && argv[i+1]){
    const v=argv[i+1]; if(/^\d+h$/.test(v)) return parseInt(v)*3600000;
  } return null;
}
function tsMs(ts){ return ts ? Date.parse(ts) : 0; }
function isoAt(h,m){ const d=new Date(); d.setUTCHours(h,m,0,0); return d.toISOString(); }
function round(v,n){ const p=10**n; return Math.round(v*p)/p; }
function readJSONL(p){ try{ return fs.readFileSync(p,'utf8').trim().split('\n').filter(Boolean).map(s=>JSON.parse(s)); }catch{ return []; } }
function appendJSONL(p,obj){ fs.appendFileSync(p, JSON.stringify(obj)+'\n'); }
function ensureDir(d){ if(!fs.existsSync(d)) fs.mkdirSync(d,{recursive:true}); }
function pickExisting(list){ return list.find(p => fs.existsSync(p)) || list[list.length-1]; }
function shq(s){ return `'${String(s).replace(/'/g,"'\\''")}'`; }
