<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Luka - Multi Model Orchestrator</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: #0a0a0a;
      color: #fafafa;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    header {
      border-bottom: 1px solid #1f2937;
      padding: 14px 20px;
      display: flex;
      align-items: center;
      gap: 14px;
    }
    .logo {
      width: 36px;
      height: 36px;
      border-radius: 10px;
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      display: grid;
      place-items: center;
      font-weight: 700;
      font-size: 18px;
      letter-spacing: 0.5px;
    }
    .status {
      flex: 1;
      font-size: 13px;
      color: #a3a3a3;
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    .status strong {
      color: #e5e5e5;
      font-size: 14px;
    }
    .status span {
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }
    .status-indicator {
      display: inline-block;
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: #ef4444;
      box-shadow: 0 0 0 2px rgba(239, 68, 68, 0.2);
    }
    .status-indicator.online {
      background: #22c55e;
      box-shadow: 0 0 0 2px rgba(34, 197, 94, 0.25);
    }
    .controls {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    select, button.mode-toggle {
      background: #111827;
      border: 1px solid #1f2937;
      color: #e5e7eb;
      padding: 6px 12px;
      border-radius: 8px;
      font-size: 12px;
      cursor: pointer;
      outline: none;
      transition: border-color 0.2s ease;
    }
    select:focus, button.mode-toggle:focus {
      border-color: #3b82f6;
    }
    button.mode-toggle {
      background: transparent;
      border-color: #3b82f6;
      color: #60a5fa;
    }
    .messages {
      flex: 1;
      overflow-y: auto;
      padding: 24px;
      display: flex;
      flex-direction: column;
      gap: 18px;
    }
    .message {
      display: flex;
      gap: 12px;
      max-width: 720px;
    }
    .message.user {
      align-self: flex-end;
      flex-direction: row-reverse;
    }
    .avatar {
      width: 34px;
      height: 34px;
      border-radius: 10px;
      background: #111827;
      display: grid;
      place-items: center;
      font-size: 13px;
      font-weight: 600;
      color: #bfdbfe;
    }
    .message.user .avatar {
      background: #2563eb;
      color: white;
    }
    .content {
      background: #111827;
      border: 1px solid #1f2937;
      padding: 14px 16px;
      border-radius: 14px;
      font-size: 14px;
      line-height: 1.6;
      color: #e5e7eb;
      width: 100%;
    }
    .message.user .content {
      background: linear-gradient(135deg, #2563eb, #1d4ed8);
      border-color: rgba(37, 99, 235, 0.2);
      color: white;
    }
    .content strong { color: #facc15; font-weight: 600; }
    .content code {
      background: rgba(148, 163, 184, 0.15);
      padding: 1px 4px;
      border-radius: 4px;
      font-family: "JetBrains Mono", Menlo, Monaco, Consolas, monospace;
      font-size: 13px;
    }
    .model-results {
      margin-top: 12px;
      display: flex;
      flex-direction: column;
      gap: 10px;
    }
    .model-result {
      background: rgba(15, 23, 42, 0.7);
      border: 1px solid #1f2937;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
    }
    .model-result.success {
      border-color: rgba(34, 197, 94, 0.35);
      background: rgba(22, 101, 52, 0.2);
    }
    .model-result.error {
      border-color: rgba(239, 68, 68, 0.35);
      background: rgba(127, 29, 29, 0.2);
    }
    .model-result header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 6px;
      color: #cbd5f5;
      font-size: 12px;
      text-transform: uppercase;
      letter-spacing: 0.6px;
    }
    .model-result p { color: #f3f4f6; }
    .model-result small { color: #9ca3af; font-size: 11px; }

    .input-area {
      padding: 18px;
      border-top: 1px solid #1f2937;
      background: rgba(10, 10, 10, 0.95);
    }
    .input-wrapper {
      background: #111827;
      border: 1px solid #1f2937;
      border-radius: 16px;
      padding: 14px;
      display: flex;
      gap: 12px;
      align-items: flex-end;
      transition: border-color 0.2s ease;
    }
    .input-wrapper:focus-within {
      border-color: #3b82f6;
      box-shadow: 0 0 0 1px rgba(59, 130, 246, 0.2);
    }
    textarea {
      flex: 1;
      background: transparent;
      border: none;
      outline: none;
      resize: none;
      color: #f9fafb;
      min-height: 24px;
      max-height: 150px;
      font-family: inherit;
      font-size: 14px;
      line-height: 1.6;
    }
    .actions {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 8px;
    }
    .actions button {
      width: 38px;
      height: 38px;
      border-radius: 12px;
      border: none;
      display: grid;
      place-items: center;
      cursor: pointer;
      transition: opacity 0.2s ease, transform 0.2s ease;
    }
    #sendButton {
      background: linear-gradient(135deg, #3b82f6, #1d4ed8);
      color: white;
    }
    #sendButton:disabled {
      opacity: 0.35;
      cursor: not-allowed;
    }
    #sendButton:not(:disabled):hover {
      opacity: 0.9;
      transform: translateY(-1px);
    }
    .helper-text {
      font-size: 11px;
      color: #6b7280;
    }
  </style>
</head>
<body>
  <header>
    <div class="logo">L</div>
    <div class="status">
      <strong>Luka Orchestrator</strong>
      <span>
        <span class="status-indicator" id="plannerStatus"></span>
        <span id="plannerLabel">Waiting for prompt…</span>
      </span>
    </div>
    <div class="controls">
      <select id="gateway">
        <option value="auto" selected>Auto dispatch (local first)</option>
      </select>
      <button class="mode-toggle" id="refreshPlan" type="button">Rescan models</button>
    </div>
  </header>

  <div class="messages" id="messages">
    <div class="message">
      <div class="avatar">L</div>
      <div class="content">
        Ready to orchestrate. Type a task and Luka will delegate it across the strongest local models using the master prompt template.
      </div>
    </div>
  </div>

  <div class="input-area">
    <div class="input-wrapper">
      <textarea id="messageInput" placeholder="Ask Luka anything…" rows="1"></textarea>
      <div class="actions">
        <button id="sendButton" type="button" disabled>
          <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <path d="M22 2L11 13M22 2l-7 20-4-9-9-4 20-7z" />
          </svg>
        </button>
        <div class="helper-text">Enter ↵ to send</div>
      </div>
    </div>
  </div>

  <script>
    const MODEL_CONFIGS = [
      {
        id: 'mcpDocker',
        name: 'MCP Docker Gateway',
        baseUrl: 'http://127.0.0.1:5012',
        healthPath: '/health',
        chatPath: '/chat',
        type: 'mcp-json',
        isLocal: true
      },
      {
        id: 'mcpFs',
        name: 'File System MCP',
        baseUrl: 'http://127.0.0.1:8765',
        healthPath: '/health',
        chatPath: '/chat',
        type: 'mcp-json',
        isLocal: true
      },
      {
        id: 'ollama',
        name: 'Ollama (OpenAI compatible)',
        baseUrl: 'http://localhost:11434',
        healthPath: '/health',
        chatPath: '/v1/chat/completions',
        type: 'openai',
        model: 'llama3.1',
        isLocal: true
      }
    ];

    const FETCH_TIMEOUT = 4000;

    const messageInput = document.getElementById('messageInput');
    const sendButton = document.getElementById('sendButton');
    const messagesContainer = document.getElementById('messages');
    const gatewaySelect = document.getElementById('gateway');
    const plannerStatus = document.getElementById('plannerStatus');
    const plannerLabel = document.getElementById('plannerLabel');
    const refreshPlanBtn = document.getElementById('refreshPlan');

    let masterPromptTemplate = '';
    let cachedPlan = null;
    let isScanning = false;

    loadMasterPrompt();
    populateGatewayOptions();
    scanModels();

    messageInput.addEventListener('input', () => {
      autoSizeTextarea();
      updateSendButton();
    });

    messageInput.addEventListener('keydown', (event) => {
      if (event.key === 'Enter' && !event.shiftKey) {
        event.preventDefault();
        sendMessage();
      }
    });

    sendButton.addEventListener('click', sendMessage);
    refreshPlanBtn.addEventListener('click', () => scanModels(true));
    gatewaySelect.addEventListener('change', () => scanModels(true));

    function autoSizeTextarea() {
      messageInput.style.height = 'auto';
      messageInput.style.height = Math.min(messageInput.scrollHeight, 150) + 'px';
    }

    function updateSendButton() {
      const hasText = messageInput.value.trim().length > 0;
      sendButton.disabled = !hasText;
    }

    async function loadMasterPrompt() {
      try {
        const response = await fetch('.codex/templates/master_prompt.md');
        if (response.ok) {
          masterPromptTemplate = await response.text();
        } else {
          console.warn('Unable to load master prompt template');
        }
      } catch (error) {
        console.warn('Failed to fetch master prompt template', error);
      }
    }

    function addMessage(type, text, options = {}) {
      const messageDiv = document.createElement('div');
      messageDiv.className = 'message' + (type === 'user' ? ' user' : '');

      const avatar = document.createElement('div');
      avatar.className = 'avatar';
      avatar.textContent = type === 'user' ? 'U' : 'L';

      const content = document.createElement('div');
      content.className = 'content';
      if (options.html) {
        content.innerHTML = text;
      } else {
        content.textContent = text;
      }

      messageDiv.appendChild(avatar);
      messageDiv.appendChild(content);
      messagesContainer.appendChild(messageDiv);
      messagesContainer.scrollTop = messagesContainer.scrollHeight;

      return { element: messageDiv, content };
    }

    function populateGatewayOptions() {
      MODEL_CONFIGS.forEach((config) => {
        const option = document.createElement('option');
        option.value = config.id;
        option.textContent = `${config.name}`;
        gatewaySelect.appendChild(option);
      });
    }

    async function scanModels(force = false) {
      if (isScanning && !force) return;
      isScanning = true;
      setPlannerState('scanning');

      const selection = gatewaySelect.value;
      const candidates = selection === 'auto'
        ? [...MODEL_CONFIGS].sort((a, b) => Number(b.isLocal) - Number(a.isLocal))
        : MODEL_CONFIGS.filter((model) => model.id === selection);

      const available = [];
      for (const model of candidates) {
        const healthy = await checkHealth(model);
        if (healthy) {
          available.push(model);
        }
      }

      cachedPlan = {
        mode: selection,
        models: available,
        timestamp: Date.now()
      };

      if (available.length > 0) {
        setPlannerState('ready', `${available.length} local model${available.length > 1 ? 's' : ''} online`);
      } else {
        setPlannerState('error', 'No local models reachable');
      }

      isScanning = false;
      return cachedPlan;
    }

    async function checkHealth(model) {
      try {
        const response = await fetchWithTimeout(model.baseUrl + model.healthPath, { method: 'GET' }, FETCH_TIMEOUT);
        if (!response || !response.ok) return false;
        return true;
      } catch (error) {
        return false;
      }
    }

    async function fetchWithTimeout(url, options = {}, timeout = FETCH_TIMEOUT) {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), timeout);

      try {
        const response = await fetch(url, { ...options, signal: controller.signal });
        clearTimeout(timer);
        return response;
      } catch (error) {
        clearTimeout(timer);
        throw error;
      }
    }

    async function sendMessage() {
      const text = messageInput.value.trim();
      if (!text) return;

      addMessage('user', text);
      messageInput.value = '';
      autoSizeTextarea();
      updateSendButton();

      const orchestratorMessage = addMessage('bot', 'Planning multi-model response…');
      orchestratorMessage.content.textContent = 'Planning multi-model response…';

      sendButton.disabled = true;

      const plan = cachedPlan && !isPlanStale(cachedPlan) ? cachedPlan : await scanModels(true);

      if (!plan || plan.models.length === 0) {
        orchestratorMessage.content.textContent = 'No local models are reachable. Please launch a gateway and try again.';
        sendButton.disabled = false;
        return;
      }

      orchestratorMessage.content.innerHTML = '';
      const summary = document.createElement('div');
      summary.innerHTML = `<strong>Dispatching to ${plan.models.length} model${plan.models.length > 1 ? 's' : ''}</strong>`;
      orchestratorMessage.content.appendChild(summary);

      const resultsList = document.createElement('div');
      resultsList.className = 'model-results';
      orchestratorMessage.content.appendChild(resultsList);

      const finalPrompt = applyPromptTemplate(text);
      const responses = [];

      for (const model of plan.models) {
        const result = await queryModel(model, finalPrompt);
        responses.push(result);
        renderModelResult(result, resultsList);
      }

      const best = selectBestResponse(responses);
      if (best && best.ok && best.text) {
        const answer = document.createElement('div');
        answer.innerHTML = `<strong>Best answer from ${escapeHtml(best.model.name)}</strong><br>${escapeHtml(best.text)}`;
        orchestratorMessage.content.insertBefore(answer, resultsList);
      } else {
        const noAnswer = document.createElement('div');
        noAnswer.innerHTML = '<strong>Unable to obtain a response from any model.</strong><br>Please verify your local services and retry.';
        orchestratorMessage.content.insertBefore(noAnswer, resultsList);
      }

      sendButton.disabled = false;
      messageInput.focus();
    }

    function applyPromptTemplate(userPrompt) {
      if (!masterPromptTemplate) return userPrompt;
      return masterPromptTemplate.replace('{{PROMPT}}', userPrompt);
    }

    function renderModelResult(result, container) {
      const wrapper = document.createElement('div');
      wrapper.className = 'model-result ' + (result.ok ? 'success' : 'error');

      const header = document.createElement('header');
      header.innerHTML = `<span>${escapeHtml(result.model.name)}</span><span>${result.duration.toFixed(0)} ms</span>`;
      wrapper.appendChild(header);

      const body = document.createElement('p');
      if (result.ok && result.text) {
        body.textContent = result.text;
      } else {
        body.textContent = result.error || 'No response received.';
      }
      wrapper.appendChild(body);

      const footer = document.createElement('small');
      footer.textContent = result.ok ? `Confidence score: ${(result.confidence * 100).toFixed(0)}%` : 'Model unreachable';
      wrapper.appendChild(footer);

      container.appendChild(wrapper);
    }

    function selectBestResponse(results) {
      const successes = results.filter((result) => result.ok && result.text);
      if (successes.length === 0) return null;
      successes.sort((a, b) => (b.confidence || 0) - (a.confidence || 0));
      return successes[0];
    }

    async function queryModel(model, prompt) {
      const start = performance.now();
      try {
        let response;
        let data;
        if (model.type === 'openai') {
          response = await fetchWithTimeout(model.baseUrl + model.chatPath, {
            method: 'POST',
            headers: {
              'Content-Type': 'application/json'
            },
            body: JSON.stringify({
              model: model.model || 'default',
              messages: [
                { role: 'system', content: 'You are a helpful assistant working inside Luka.' },
                { role: 'user', content: prompt }
              ]
            })
          }, FETCH_TIMEOUT);
          if (!response) throw new Error('No response');
          data = await safeJson(response);
          const text = data?.choices?.[0]?.message?.content || '';
          return {
            ok: response.ok && Boolean(text),
            text: text || '',
            confidence: computeConfidence(text),
            model,
            duration: performance.now() - start
          };
        }

        response = await fetchWithTimeout(model.baseUrl + model.chatPath, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({ prompt })
        }, FETCH_TIMEOUT);
        if (!response) throw new Error('No response');
        data = await safeJson(response);
        const text = data?.reply || data?.response || data?.message || '';
        return {
          ok: response.ok && Boolean(text),
          text: text || '',
          confidence: computeConfidence(text),
          model,
          duration: performance.now() - start
        };
      } catch (error) {
        return {
          ok: false,
          error: error.message || 'Unknown error',
          model,
          duration: performance.now() - start,
          confidence: 0
        };
      }
    }

    function computeConfidence(text) {
      if (!text) return 0;
      const lengthScore = Math.min(text.length / 400, 1);
      const structureBonus = /\n|\*/.test(text) ? 0.15 : 0;
      return Math.min(1, lengthScore + structureBonus);
    }

    function escapeHtml(value) {
      return value
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    function isPlanStale(plan) {
      const FIFTEEN_SECONDS = 15 * 1000;
      return Date.now() - plan.timestamp > FIFTEEN_SECONDS;
    }

    async function safeJson(response) {
      try {
        return await response.json();
      } catch (error) {
        return null;
      }
    }

    function setPlannerState(state, message) {
      plannerStatus.classList.remove('online');
      if (state === 'ready') {
        plannerStatus.classList.add('online');
        plannerLabel.textContent = message || 'Local models ready';
      } else if (state === 'scanning') {
        plannerLabel.textContent = 'Scanning local models…';
      } else {
        plannerLabel.textContent = message || 'Models offline';
      }
    }

    autoSizeTextarea();
    updateSendButton();
    messageInput.focus();
  </script>
</body>
</html>
