#!/usr/bin/env node
/**
 * Documentation Publisher for GitHub Pages
 * Converts markdown files from docs/ to HTML in dist/docs/
 * 
 * Usage: node run/publish_docs.cjs
 */

const fs = require('fs');
const path = require('path');
const { execSync } = require('child_process');

const DOCS_DIR = path.join(process.cwd(), 'docs');
const OUTPUT_DIR = path.join(process.cwd(), 'dist', 'docs');
const ASSETS_DIR = path.join(OUTPUT_DIR, 'assets');

// Ensure output directories exist
if (!fs.existsSync(OUTPUT_DIR)) {
  fs.mkdirSync(OUTPUT_DIR, { recursive: true });
}
if (!fs.existsSync(ASSETS_DIR)) {
  fs.mkdirSync(ASSETS_DIR, { recursive: true });
}

console.log('üöÄ Publishing documentation...');
console.log(`üìÅ Source: ${DOCS_DIR}`);
console.log(`üìÅ Output: ${OUTPUT_DIR}`);

// Check if pandoc is available
let pandocAvailable = false;
try {
  execSync('which pandoc', { stdio: 'ignore' });
  pandocAvailable = true;
} catch (e) {
  console.warn('‚ö†Ô∏è  pandoc not found, using basic markdown conversion');
}

// Simple markdown to HTML converter (fallback if pandoc unavailable)
function simpleMarkdownToHtml(markdown, title) {
  let html = markdown
    .replace(/^# (.*$)/gim, '<h1>$1</h1>')
    .replace(/^## (.*$)/gim, '<h2>$1</h2>')
    .replace(/^### (.*$)/gim, '<h3>$1</h3>')
    .replace(/^#### (.*$)/gim, '<h4>$1</h4>')
    .replace(/^\*\*(.*)\*\*/gim, '<strong>$1</strong>')
    .replace(/^\*(.*)\*/gim, '<em>$1</em>')
    .replace(/^```([\s\S]*?)```/gim, '<pre><code>$1</code></pre>')
    .replace(/^`(.*?)`/gim, '<code>$1</code>')
    .replace(/^\n/gim, '<br>');

  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${title || 'Documentation'}</title>
  <link rel="stylesheet" href="/docs/assets/docs.css">
</head>
<body>
  <header>
    <h1>${title || 'Documentation'}</h1>
  </header>
  <main>
    ${html}
  </main>
  <footer>
    <p>Generated by 02luka Documentation Publisher</p>
  </footer>
  <script src="/docs/assets/docs.js"></script>
</body>
</html>`;
}

// Process markdown files
function processMarkdownFiles() {
  const files = [];
  
  function walkDir(dir, fileList = []) {
    const entries = fs.readdirSync(dir, { withFileTypes: true });
    
    for (const entry of entries) {
      const fullPath = path.join(dir, entry.name);
      
      if (entry.isDirectory()) {
        // Skip hidden directories and node_modules
        if (!entry.name.startsWith('.') && entry.name !== 'node_modules') {
          walkDir(fullPath, fileList);
        }
      } else if (entry.isFile() && entry.name.endsWith('.md')) {
        fileList.push(fullPath);
      }
    }
    
    return fileList;
  }
  
  if (fs.existsSync(DOCS_DIR)) {
    files.push(...walkDir(DOCS_DIR));
  } else {
    console.warn(`‚ö†Ô∏è  Docs directory not found: ${DOCS_DIR}`);
    return [];
  }
  
  console.log(`üìÑ Found ${files.length} markdown files`);
  
  const processed = [];
  
  for (const filePath of files) {
    const relativePath = path.relative(DOCS_DIR, filePath);
    const fileName = path.basename(filePath, '.md');
    const htmlFileName = `${fileName}.html`;
    const outputPath = path.join(OUTPUT_DIR, htmlFileName);
    
    try {
      const markdown = fs.readFileSync(filePath, 'utf8');
      const title = markdown.match(/^# (.+)$/m)?.[1] || fileName;
      
      let html;
      
      if (pandocAvailable) {
        // Use pandoc for better conversion
        try {
          html = execSync(`pandoc "${filePath}" -o - --standalone --metadata title="${title}" --toc --toc-depth=3 --css="/docs/assets/docs.css"`, {
            encoding: 'utf8',
            maxBuffer: 10 * 1024 * 1024 // 10MB
          });
        } catch (e) {
          console.warn(`‚ö†Ô∏è  pandoc failed for ${relativePath}, using fallback`);
          html = simpleMarkdownToHtml(markdown, title);
        }
      } else {
        html = simpleMarkdownToHtml(markdown, title);
      }
      
      fs.writeFileSync(outputPath, html, 'utf8');
      processed.push({ fileName: htmlFileName, title, path: relativePath });
      console.log(`‚úÖ Converted: ${relativePath} ‚Üí ${htmlFileName}`);
    } catch (error) {
      console.error(`‚ùå Error processing ${relativePath}:`, error.message);
    }
  }
  
  return processed;
}

// Generate CSS
function generateCSS() {
  const css = `:root {
  --primary: #2c3e50;
  --secondary: #3498db;
  --background: #ecf0f1;
  --text: #2c3e50;
  --border: #bdc3c7;
  --dark-bg: #1a1a1a;
  --dark-text: #e0e0e0;
  --dark-border: #444;
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
  line-height: 1.6;
  color: var(--text);
  background: var(--background);
  padding: 20px;
  transition: background-color 0.3s, color 0.3s;
}

body.dark-mode {
  background: var(--dark-bg);
  color: var(--dark-text);
}

header {
  background: var(--primary);
  color: white;
  padding: 2rem;
  margin-bottom: 2rem;
  border-radius: 8px;
}

body.dark-mode header {
  background: #1a252f;
}

header h1 {
  font-size: 2.5rem;
  margin-bottom: 0.5rem;
}

main {
  background: white;
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 2px 4px rgba(0,0,0,0.1);
  max-width: 900px;
  margin: 0 auto;
}

body.dark-mode main {
  background: #2a2a2a;
  box-shadow: 0 2px 4px rgba(0,0,0,0.3);
}

nav ul {
  list-style: none;
}

nav li {
  padding: 0.75rem 0;
  border-bottom: 1px solid var(--border);
}

body.dark-mode nav li {
  border-bottom-color: var(--dark-border);
}

nav li:last-child {
  border-bottom: none;
}

nav a {
  color: var(--secondary);
  text-decoration: none;
  font-size: 1.1rem;
  transition: color 0.2s;
}

nav a:hover {
  color: var(--primary);
}

h1, h2, h3, h4, h5, h6 {
  margin: 1.5rem 0 1rem;
  color: var(--primary);
}

body.dark-mode h1,
body.dark-mode h2,
body.dark-mode h3,
body.dark-mode h4,
body.dark-mode h5,
body.dark-mode h6 {
  color: var(--dark-text);
}

p {
  margin-bottom: 1rem;
}

code {
  background: #f4f4f4;
  padding: 2px 6px;
  border-radius: 3px;
  font-family: "Monaco", "Courier New", monospace;
}

body.dark-mode code {
  background: #3a3a3a;
  color: #e0e0e0;
}

pre {
  background: #f4f4f4;
  padding: 1rem;
  border-radius: 5px;
  overflow-x: auto;
  margin: 1rem 0;
}

body.dark-mode pre {
  background: #3a3a3a;
}

pre code {
  background: none;
  padding: 0;
}

footer {
  text-align: center;
  margin-top: 2rem;
  color: #7f8c8d;
  font-size: 0.9rem;
}

body.dark-mode footer {
  color: #999;
}

#TOC {
  background: #f8f9fa;
  padding: 1rem;
  border-left: 4px solid var(--secondary);
  margin: 1rem 0;
}

body.dark-mode #TOC {
  background: #333;
  border-left-color: var(--secondary);
}

#TOC ul {
  list-style: none;
}

#TOC a {
  color: var(--text);
  text-decoration: none;
}

body.dark-mode #TOC a {
  color: var(--dark-text);
}

#TOC a:hover {
  color: var(--secondary);
}

.dark-mode-toggle {
  position: fixed;
  top: 20px;
  right: 20px;
  background: var(--primary);
  color: white;
  border: none;
  padding: 10px 15px;
  border-radius: 5px;
  cursor: pointer;
  font-size: 14px;
  z-index: 1000;
}

.dark-mode-toggle:hover {
  background: #34495e;
}
`;

  fs.writeFileSync(path.join(ASSETS_DIR, 'docs.css'), css, 'utf8');
  console.log('‚úÖ Generated CSS');
}

// Generate JavaScript
function generateJS() {
  const js = `// Dark mode toggle
(function() {
  const darkModeToggle = document.createElement('button');
  darkModeToggle.className = 'dark-mode-toggle';
  darkModeToggle.textContent = 'üåô Dark Mode';
  document.body.appendChild(darkModeToggle);

  // Check saved preference
  const isDark = localStorage.getItem('darkMode') === 'true';
  if (isDark) {
    document.body.classList.add('dark-mode');
    darkModeToggle.textContent = '‚òÄÔ∏è Light Mode';
  }

  darkModeToggle.addEventListener('click', () => {
    document.body.classList.toggle('dark-mode');
    const isDarkNow = document.body.classList.contains('dark-mode');
    localStorage.setItem('darkMode', isDarkNow);
    darkModeToggle.textContent = isDarkNow ? '‚òÄÔ∏è Light Mode' : 'üåô Dark Mode';
  });

  // Copy link functionality
  document.querySelectorAll('h1, h2, h3, h4, h5, h6').forEach(heading => {
    heading.style.cursor = 'pointer';
    heading.addEventListener('click', () => {
      const id = heading.id || heading.textContent.toLowerCase().replace(/\\s+/g, '-');
      heading.id = id;
      const url = window.location.origin + window.location.pathname + '#' + id;
      navigator.clipboard.writeText(url).then(() => {
        const originalText = heading.textContent;
        heading.textContent = '‚úì ' + originalText;
        setTimeout(() => {
          heading.textContent = originalText;
        }, 2000);
      });
    });
  });
})();
`;

  fs.writeFileSync(path.join(ASSETS_DIR, 'docs.js'), js, 'utf8');
  console.log('‚úÖ Generated JavaScript');
}

// Generate index page
function generateIndex(processedFiles) {
  const indexHtml = `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>02luka Documentation</title>
  <link rel="stylesheet" href="/docs/assets/docs.css">
</head>
<body>
  <header>
    <h1>02luka Documentation</h1>
    <p>Public documentation repository</p>
  </header>
  <main>
    <nav>
      <h2>Available Documents</h2>
      <ul id="doc-list">
${processedFiles.map(file => `        <li><a href="/docs/${file.fileName}">${file.title}</a></li>`).join('\n')}
      </ul>
    </nav>
  </main>
  <footer>
    <p>Generated by 02luka Documentation Publisher</p>
    <p>Last updated: ${new Date().toISOString()}</p>
  </footer>
  <script src="/docs/assets/docs.js"></script>
</body>
</html>`;

  fs.writeFileSync(path.join(OUTPUT_DIR, 'index.html'), indexHtml, 'utf8');
  console.log('‚úÖ Generated index page');
}

// Main execution
try {
  const processedFiles = processMarkdownFiles();
  
  if (processedFiles.length === 0) {
    console.warn('‚ö†Ô∏è  No markdown files processed');
    process.exit(1);
  }
  
  generateCSS();
  generateJS();
  generateIndex(processedFiles);
  
  console.log(`\n‚ú® Successfully published ${processedFiles.length} documents`);
  console.log(`üìÅ Output directory: ${OUTPUT_DIR}`);
} catch (error) {
  console.error('‚ùå Error:', error.message);
  process.exit(1);
}
