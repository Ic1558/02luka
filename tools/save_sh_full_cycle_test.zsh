#!/usr/bin/env zsh
set -euo pipefail

# save_sh_full_cycle_test.zsh
#
# Purpose:
#   Run the full save.sh cycle for CLS / CLC lanes, capture before/after
#   git state, and write a Markdown report under g/reports/system/.
#
# Notes:
#   - Does NOT modify workflows, dashboard, or security code.
#   - Does NOT push; only invokes local save.sh.
#   - Assumes repo layout: ~/02luka/g with save.sh at repo root.

SCRIPT_DIR="${0:A:h}"
G_DIR="${SCRIPT_DIR:A:h}"                 # .../g/tools -> .../g
REPO_ROOT="${G_DIR:A:h}"                 # .../g      -> ~/02luka (expected)
REPORTS_DIR="$G_DIR/reports/system"

mkdir -p "$REPORTS_DIR"

usage() {
  cat <<EOFU
Usage: $(basename "$0") [--lane cls|clc|both]

Options:
  --lane cls   Run save.sh in CLS lane only  (LUKA_LANE=CLS)
  --lane clc   Run save.sh in CLC lane only  (LUKA_LANE=CLC)
  --lane both  Run both lanes (default)

The script:
  - Captures 'git status --short' before/after
  - Invokes ./save.sh from repo root
  - Writes Markdown reports to g/reports/system/
EOFU
}

LANE_MODE="both"

while [[ $# -gt 0 ]]; do
  case "$1" in
    --lane)
      shift
      [[ $# -gt 0 ]] || { echo "Missing value for --lane" >&2; exit 1; }
      LANE_MODE="$1"
      shift
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      echo "Unknown argument: $1" >&2
      usage
      exit 1
      ;;
  esac
 done

SAVE_SH="$REPO_ROOT/save.sh"
if [[ ! -x "$SAVE_SH" ]]; then
  echo "[!] save.sh not found or not executable at: $SAVE_SH" >&2
  exit 1
fi

timestamp() {
  date '+%Y-%m-%d %H:%M:%S %z'
}

iso_stamp() {
  date -u '+%Y%m%dT%H%M%SZ'
}

run_lane() {
  local lane="$1"  # CLS or CLC
  local iso run_id report_path

  iso="$(iso_stamp)"
  run_id="save-${lane}-${iso}"
  report_path="$REPORTS_DIR/save_sh_full_cycle_${lane}_${iso}.md"

  echo "[*] Running save.sh full cycle for lane: ${lane}"

  # Capture before state
  local before_branch before_status before_head
  before_branch="$(git -C "$REPO_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')"
  before_head="$(git -C "$REPO_ROOT" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
  before_status="$(git -C "$REPO_ROOT" status --short || true)"

  # Run save.sh with lane environment
  local exit_code
  (
    cd "$REPO_ROOT"
    export LUKA_LANE="$lane"
    echo "[*] [$lane] $(timestamp): running save.sh with LUKA_LANE=$lane"
    ./save.sh || exit $?
  )
  exit_code=$?

  # Capture after state
  local after_branch after_head after_status last_commit
  after_branch="$(git -C "$REPO_ROOT" rev-parse --abbrev-ref HEAD 2>/dev/null || echo 'unknown')"
  after_head="$(git -C "$REPO_ROOT" rev-parse --short HEAD 2>/dev/null || echo 'unknown')"
  after_status="$(git -C "$REPO_ROOT" status --short || true)"
  last_commit="$(git -C "$REPO_ROOT" log -n 1 --pretty=format:'%h %cd %s' 2>/dev/null || echo 'none')"

  # Write report
  cat > "$report_path" <<EOFR
# save.sh Full-Cycle Test Report â€” Lane: ${lane}

- **Run ID:** ${run_id}
- **Timestamp:** $(timestamp)
- **Lane:** ${lane}
- **Exit code:** ${exit_code}

## Git state (before)

- **Branch:** ${before_branch}
- **HEAD:** ${before_head}

\`\`\`text
${before_status}
\`\`\`

## Git state (after)

- **Branch:** ${after_branch}
- **HEAD:** ${after_head}
- **Last commit:** ${last_commit}

\`\`\`text
${after_status}
\`\`\`

## Notes

- Command: \`LUKA_LANE=${lane} ./save.sh\`
- This report is generated by tools/save_sh_full_cycle_test.zsh.
- No workflows, dashboard code, or security files were modified by this tool.
EOFR

  echo "[+] Lane ${lane} complete. Report written to: ${report_path}"
  return "$exit_code"
}

case "$LANE_MODE" in
  cls)
    run_lane "CLS"
    ;;
  clc)
    run_lane "CLC"
    ;;
  both)
    # Run CLS then CLC; do not stop on first failure, but propagate non-zero
    local rc_cls=0 rc_clc=0
    run_lane "CLS" || rc_cls=$?
    run_lane "CLC" || rc_clc=$?
    if (( rc_cls != 0 || rc_clc != 0 )); then
      echo "[!] One or more lanes failed (CLS=${rc_cls}, CLC=${rc_clc})" >&2
      exit 1
    fi
    ;;
  *)
    echo "Invalid lane mode: $LANE_MODE" >&2
    usage
    exit 1
    ;;
 esac
